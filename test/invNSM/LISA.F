C
C
C
C             PROGRAM LISA ... NONNEGATIVE LEAST SQUARES INVERSION
C                                    OR
C                              SINGULAR VALUE DECOMPOSITION INVERSE
C
C
      INCLUDE 'ARSZLISA.DAT'
      COMMON/ALL/A(MDA,N)
      COMMON/REST/B(M),X(N),W(N),ZZ(M)
      COMMON/OTHER/INDEX(N)
      DIMENSION SYN(5000)
      CHARACTER*40 IAFILE,IBFILE
C
      WRITE(6,30)
  30  FORMAT(1X,'WARNING....THE PARAMETERS MDA,M,N, AND N3',/, 
     +1X,'MUST BE SET EXACTLY, NOT OVER DIMENSIONED ')
      WRITE(6,31)
  31  FORMAT(1X,'IOP=1, NONNEGATIVE LEAST SQUARES INVERSE',/,
     +1X,'IOP=2, SINGULAR VALUE DECOMPOSITION INVERSE',/,
     +1X,'ENTER VALUE OF IOP ')
      READ(5,*) IOP
      WRITE(6,32)
  32  FORMAT(1X,'ENTER NAME OF FILE CONTAINING ARRAY  A ',/,
     +1X,'(THE SYNTHETICS ARRAY) ')
      READ(5,33) IAFILE
  33  FORMAT(A)
      OPEN(UNIT=7,FILE=IAFILE,STATUS='OLD',ACCESS='SEQUENTIAL',
     +FORM='UNFORMATTED')
      WRITE(6,34)
  34  FORMAT(1X,'ENTER NAME OF FILE CONTAINING ARRAY  B ',/,
     +1X,'(THE ARRAY OF OBSERVATIONS) ')
      READ(5,33) IBFILE
      OPEN(UNIT=8,FILE=IBFILE,STATUS='OLD',ACCESS='SEQUENTIAL',
     +FORM='UNFORMATTED')
      WRITE(6,35)
  35  FORMAT(1X,'HOW MANY OBSERVATION RECORDS ARE YOU USING IN',/,
     +1X,'THE INVERSION ')
      READ(5,*) NREC
      WRITE(6,36)
  36  FORMAT(1X,'HOW MANY SUBFAULTS ARE THERE ')
      READ(5,*) NSUBF
      WRITE(6,37)
  37  FORMAT(1X,'HOW MANY DIFFERENT MECHANISMS (GREENS FUNCTIONS)',/,
     +1X,'ARE THERE PER SUBFAULT ')
      READ(5,*) NMECH
      WRITE(6,38)
  38  FORMAT(1X,'HOW MANY TIME WINDOWS ARE THERE')
      READ(5,*) JW
      NN=NSUBF*NMECH*JW
      WRITE(6,39)
  39  FORMAT(1X,'ENTER THE VALUE OF ISMOTH',/,
     +1X,'ISMOTH=0...NO SMOOTHING SUBMATRICES',/,
     +1X,'ISMOTH=1...READ IN SMOOTHING SUBMATRICES FROM JULIE DISK',/,
     +1X,'           FILES (JULIEA.DAT AND JULIEB.DAT)',/,
     +1X,'ISMOTH=2...GENERATE SMOOTHING SUBMATRICES IN LISA AND APPEND',/,
     +1X,'           THEM TO THE A AND B MATRICES (AS FROM SEQUEN.F)')
      READ(5,*) ISMOTH
      DO 10 J=1,NREC
      READ(7) NT
      READ(8) NT2
      IF(NT .NE. NT2) GO TO 100
      WRITE(6,999) NT
 999  FORMAT(1X,'LENGTH OF THIS RECORD IS = ',I5)
      IF(J .EQ. 1) L2=NT
      IF(J .GT. 1) L2=L2+NT
      IF(J .EQ. 1) L1=1
      IF(J .GT. 1) L1=L2-NT+1
      DO 11 K=1,NN
      READ(7) (SYN(I),I=1,NT)
      DO 444 I=1,NT
 444  A(L1+I-1,K)=SYN(I)
  11  CONTINUE
      MUP=L1+NT-1
      READ(8) (B(IP),IP=L1,MUP)
  10  CONTINUE
C
C     READ IN SMOOTHING SUBMATRICES.
C
      IF(ISMOTH .EQ. 0) GO TO 21
      IF(ISMOTH .EQ. 1) THEN
      READ(8) NROW
      MUP=L2+NROW
      READ(8) (B(IP),IP=L2+1,MUP)
      READ(7) NROW
      DO 22 K=1,NROW
      READ(7) (SYN(I),I=1,NN)
      DO 23 I=1,NN
  23  A(L2+K,I)=SYN(I)
  22  CONTINUE
   8  FORMAT(I8)
      GO TO 21
      END IF
      IF(ISMOTH .EQ. 2) CALL CONSTR(MUP,B,NSUBF,JW,NREC,NMECH,SYN)
  21  CLOSE(7)
      CLOSE(8)
      OPEN(UNIT=9,FILE='LISAOUT.DAT',STATUS='NEW')
      IF(IOP .EQ. 2) GO TO 12
      CALL NNLS(RNORM,MODE)
      GO TO 16
  12  MDATA=NREC*NT
      ISCALE=1
      CALL SVA(MDATA,ISCALE)
      GO TO 17
  16  WRITE(9,2) RNORM
      WRITE(9,3) MODE
      WRITE(9,4)
      WRITE(9,5) (X(I), I=1,N)
      WRITE(9,6)
      WRITE(9,5) (W(I), I=1,N)
   2  FORMAT(' EUCLIDEAN NORM OF THE FINAL RESIDUAL VECTOR,
     +((B-AX))= ',E14.5)
   3  FORMAT(' MODE= ',I5)
   4  FORMAT(//,' SOLUTION VECTOR')
   5  FORMAT(1X,6E13.5)
   6  FORMAT(//,' DUAL VECTOR')
  17  CLOSE(9)
      GO TO 50
  100 WRITE(6,14) NT,NT2
  14  FORMAT(1X,'NT= ',I5,' IS NOT EQUAL TO NT2= ',I5)
  15  FORMAT(4A4)
  50  STOP
      END
C     SUBROUTINE NNLS  (A,MDA,M,N,B,X,RNORM,W,ZZ,INDEX,MODE)
C     C.L.LAWSON AND R.J.HANSON 'SOLVING LEAST SQUARES PROBLEMS', PRENTICE-
C     HALL.
C     1974.
C
C        ......  NONNEGATIVE LEAST SQUARES  ......
C
C     GIVEN AN M BY N MATRIX, A, AND AN M-VECTOR, B, COMPUTE AN
C     N-VECTOR, X, WHICH SOLVES THE LEAST SQUARES PROBLEM
C
C                A * X = B  SUBJECT TO X .GE. 0
C
C     A(),MDA,M,N  MDA IS THE FIRST DIMENSIONING PARAMETER FOR
C     THE ARRAY, A().  ON ENTRY A() CONTAINS THE M BY N MATRIX A.  ON
C     EXIT A() CONTAINS THE PRODUCT MATRIX, Q*A, WHERE Q IS AN M BY M
C     ORTHOGONAL MATRIX GENERATED IMPLICITLY BY THIS SUBROUTINE.
C     B()     ON ENTRY B() CONTAINS THE M-VECTOR, B.  ON EXIT B()
C             CONTAINS Q*B.
C     X()     ON ENTRY X() NEED NOT BE INITIALIZED.  ON EXIT X() WILL
C             CONTAIN THE SOLUTION VECTOR.
C     RNORM   ON EXIT RNORM CONTAINS THE EUCLIDEAN NORM OF THE RESIDUAL
C             VECTOR.
C     W()     AN N-ARRAY OF WORKING SPACE.  ON EXIT W() WILL CONTAIN
C             THE DUAL SOLUTION VECTOR.  W WILL SATISFY W(I) = 0.
C             FOR ALL I IN SET P AND W(I) .LE. 0. FOR ALL I IN SET Z.
C     ZZ()    AN M-ARRAY OF WORKING SPACE.
C     INDEX() AN INTEGER WORKING ARRAY OF LENGTH AT LEAST N.
C             ON EXIT THE CONTENTS OF THIS ARRAY DEFINE THE SETS P
C             AND Z AS FOLLOWS..
C
C             INDEX(1)  THRU  INDEX(NSETP) = SET P.
C             INDEX(IZ1)  THUR  INDEX(IZ2) = SET Z.
C             IZ1 = NSETP + 1 = NPP1
C             IZ2 = N
C     MODE    THIS IS A SUCCESS-FAILURE FLAG WITH THE FOLLOWING
C             MEANINGS..
C
C             1    THE SOLUTION HAS BEEN COMPUTED SUCCESSFULLY.
C             2    THE DIMENSIONS OF THE PROBLEM ARE BAD.
C                  EITHER M .LE. 0 OR N .LE. 0.
C             3    ITERATION COUNT EXCEEDED.  MORE THAN 3*N ITERATIONS.
C
C
C
      SUBROUTINE NNLS(RNORM,MODE)
      INCLUDE 'ARSZLISA.DAT'
      COMMON/ALL/A(MDA,N)
      COMMON/REST/B(M),X(N),W(N),ZZ(M)
      COMMON/OTHER/INDEX(N)
      ZERO=0.
      ONE=1.
      TWO=2.
      FACTOR=0.01
C
      MODE=1
      IF(M .GT. 0 .AND. N .GT. 0) GO TO 10
      MODE=2
      RETURN
  10  ITER=0
      ITMAX=3*N
C
C                   INITIALIZE THE ARRAYS INDEX() AND X().
C
      DO 20 I=1,N
      X(I)=ZERO
  20  INDEX(I)=I
C
      IZ2=N
      IZ1=1
      NSETP=0
      NPP1=1
C
C                  .....  MAIN LOOP BEGINS HERE  .....
C
  30  CONTINUE
C
C                  QUIT IF ALL COEFFICIENTS ARE ALREADY IN THE
C                  SOLUTION OR IF M COLS OF A HAVE BEEN TRIANGULARIZED.
C
      IF(IZ1 .GT. IZ2 .OR. NSETP .GE. M) GO TO 350
C
C            COMPUTE COMPONENTS OF THE DUAL (NEGATIVE GRADIENT) VECTOR W().
C
      DO 50 IZ=IZ1,IZ2
      J=INDEX(IZ)
      SM=ZERO
      DO 40 L=NPP1,M
  40  SM=SM+A(L,J)*B(L)
  50  W(J)=SM
C
C                  FIND LARGEST POSITIVE W(J).
C
  60  WMAX=ZERO
      DO 70 IZ=IZ1,IZ2
      J=INDEX(IZ)
      IF(W(J) .LE. WMAX) GO TO 70
      WMAX=W(J)
      IZMAX=IZ
  70  CONTINUE
C
C                  IF WMAX .LE. 0. GO TO TERMINATION.
C                  THIS INDICATES SATISFACTION OF THE KUHN-TUCKER CONDITIONS.
C
      IF(WMAX) 350,350,80
  80  IZ=IZMAX
      J=INDEX(IZ)
C
C          THE SIGN OF W(J) IS OK FOR J TO BE MOVED TO SET P.  BEGIN THE
C          TRANSFORMATION AND CHECK NEW DIAGONAL ELEMENT TO AVOID NEAR
C          LINEAR DEPENDENCE.
C
      ASAVE=A(NPP1,J)
      CALL H12(1,NPP1,NPP1+1,M,A(1,J),1,UP,DUMMY,1,1,0)
      UNORM=ZERO
      IF(NSETP .EQ. 0) GO TO 100
      DO 90 L=1,NSETP
  90  UNORM=UNORM+A(L,J)**2
 100  UNORM=SQRT(UNORM)
      IF(DIFF(UNORM+ABS(A(NPP1,J))*FACTOR,UNORM)) 130,130,110
C
C          COL J IS SUFFICIENTLY INDEPENDENT.  COPY B INTO ZZ, UPDATE
C          ZZ AND SOLVE FOR ZTEST ( = PROPOSED NEW VALUE FOR X(J) ).
C
 110  DO 120 L=1,M
 120  ZZ(L)=B(L)
      CALL H12(2,NPP1,NPP1+1,M,A(1,J),1,UP,ZZ,1,1,1)
      ZTEST=ZZ(NPP1)/A(NPP1,J)
C
C                    SEE IF ZTEST IS POSITIVE.
C
      IF(ZTEST) 130,130,140
C
C          REJECT J AS A CANDIDATE TO BE MOVED FROM SET Z TO SET P.
C          RESTORE A(NPP1,J), SET W(J)=0., AND LOOP BACK TO TEST DUAL
C          COEFFS AGAIN.
C
 130  A(NPP1,J)=ASAVE
      W(J)=ZERO
      GO TO 60
C
C     THE INDEX J=INDEX(IZ) HAS BEEN SELECTED TO BE MOVED FROM SET
C     Z TO SET P.  UPDATE B, UPDATE INDICES, APPLY HOUSEHOLDER
C     TRANSFORMATIONS TO COLS IN NEW SET Z, ZERO SUBDIAGONAL ELTS IN
C     COL J, SET W(J)=0.
C
 140  DO 150 L=1,M
 150  B(L)=ZZ(L)
C
      INDEX(IZ)=INDEX(IZ1)
      INDEX(IZ1)=J
      IZ1=IZ1+1
      NSETP=NPP1
      NPP1=NPP1+1
C
      IF(IZ1 .GT. IZ2) GO TO 170
      DO 160 JZ=IZ1,IZ2
      JJ=INDEX(JZ)
 160  CALL H12(2,NSETP,NPP1,M,A(1,J),1,UP,A(1,JJ),1,MDA,1)
 170  CONTINUE
C
      IF(NSETP .EQ. M) GO TO 190
      DO 180 L=NPP1,M
 180  A(L,J)=ZERO
 190  CONTINUE
C
      W(J)=ZERO
C
C                  SOLVE THE TRIANGULAR SYSTEM. STORE THE SOLUTION
C                  TEMPORARILY IN ZZ().
C
      ASSIGN 200 TO NEXT
      GO TO 400
 200  CONTINUE
C
C                  .....  SECONDARY LOOP BEGINS HERE  .....
C                             ITERATION COUNTER
C
 210  ITER=ITER+1
      IF(ITER .LE. ITMAX) GO TO 220
      MODE=3
      WRITE(6,440)
      GO TO 350
 220  CONTINUE
C
C                  SEE IF ALL NEW CONSTRAINED COEFFS ARE FEASIBLE.
C                  IF NOT COMPUTE ALPHA.
C
      ALPHA=TWO
      DO 240 IP=1,NSETP
      L=INDEX(IP)
      IF(ZZ(IP)) 230,230,240
C
 230  T=-X(L)/(ZZ(IP)-X(L))
      IF(ALPHA .LE. T) GO TO 240
      ALPHA=T
      JJ=IP
 240  CONTINUE
C
C          IF ALL NEW CONSTRAINED COEFFS ARE FEASIBLE THEN ALPHA WILL
C          STILL = 2.  IF SO EXIT FROM SECONDARY LOOP TO MAIN LOOP.
C
      IF(ALPHA .EQ. TWO) GO TO 330
C
C          OTHERWISE USE ALPHA WHICH WILL BE BETWEEN 0. AND 1. TO
C          INTERPOLATE BETWEEN THE OLD X AND THE NEW ZZ.
C
      DO 250 IP=1,NSETP
      L=INDEX(IP)
 250  X(L)=X(L)+ALPHA*(ZZ(IP)-X(L))
C
C             MODIFY A AND B AND THE INDEX ARRAYS TO MOVE COEFFICIENT
C             I FROM SET P TO SET Z.
C
      I=INDEX(JJ)
 260  X(I)=ZERO
C
      IF(JJ .EQ. NSETP) GO TO 290
      JJ=JJ+1
      DO 280 J=JJ,NSETP
      II=INDEX(J)
      INDEX(J-1)=II
      CALL G1(A(J-1,II),A(J,II),CC,SS,A(J-1,II))
      A(J,II)=ZERO
      DO 270 L=1,N
      IF(L .NE. II) CALL G2(CC,SS,A(J-1,L),A(J,L))
 270  CONTINUE
 280  CALL G2(CC,SS,B(J-1),B(J))
 290  NPP1=NSETP
      NSETP=NSETP-1
      IZ1=IZ1-1
      INDEX(IZ1)=I
C
C             SEE IF THE REMAINING COEFFS IN SET P ARE FEASIBLE.  THEY
C             SHOULD BE BECAUSE OF THE WAY ALPHA WAS DETERMINED.  IF
C             ANY ARE INFEASIBLE IT IS DUE TO ROUND-OFF ERROR.  ANY
C             THAT ARE NONPOSITIVE WILL BE SET TO ZERO AND MOVED FROM
C             SET P TO SET Z.
C
      DO 300 JJ=1,NSETP
      I=INDEX(JJ)
      IF(X(I)) 260,260,300
 300  CONTINUE
C
C             COPY B() INTO ZZ().  THEN SOLVE AGAIN AND LOOP BACK.
C
      DO 310 I=1,M
 310  ZZ(I)=B(I)
      ASSIGN 320 TO NEXT
      GO TO 400
 320  CONTINUE
      GO TO 210
C
C             .....  END OF SECONDARY LOOP  .....
C
 330  DO 340 IP=1,NSETP
      I=INDEX(IP)
 340  X(I)=ZZ(IP)
C
C             ALL NEW COEFFS ARE POSITIVE.  LOOP BACK TO BEGINNING.
C
      GO TO 30
C
C             .....  END OF MAIN LOOP  .....
C             COME TO HERE FOR TERMINATION.  COMPUTE THE NORM
C             OF THE FINAL RESIDUAL VECTOR.
C
 350  SM=ZERO
      IF(NPP1 .GT. M) GO TO 370
      DO 360 I=NPP1,M
 360  SM=SM+B(I)**2
      GO TO 390
 370  DO 380 J=1,N
 380  W(J)=ZERO
 390  RNORM=SQRT(SM)
      RETURN
C
C             THE FOLLOWING BLOCK OF CODE IS USED AS AN INTERNAL
C             SUBROUTINE TO SOLVE THE TRIANGULAR SYSTEM, PUTTING
C             THE SOLUTION IN ZZ().
C
 400  DO 430 L=1,NSETP
      IP=NSETP+1-L
      IF(L .EQ. 1) GO TO 420
      DO 410 II=1,IP
 410  ZZ(II)=ZZ(II)-A(II,JJ)*ZZ(IP+1)
 420  JJ=INDEX(IP)
 430  ZZ(IP)=ZZ(IP)/A(IP,JJ)
      GO TO NEXT, (200,320)
 440  FORMAT(1X,' NNLS QUITTING ON ITERATION COUNT.')
      END
C
C     SUBROUTINE H12(MODE,LPIVOT,L1,M,U,IUE,UP,C,ICE,ICV,NCV)
C     C.L.LAWSON AND R.J.HANSON, 'SOLVING LEAST SQUARES PROBLEMS',
C     PRENTICE-HALL, 1974.
C
C     CONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER
C     TRANSFORMATION..    Q = I + U*(U**T)/B
C
C     MODE    = 1 OR 2 TO SELECT ALGORITHM H1 OR H2.
C     LPIVOT  IS THE INDEX OF THE PIVOT ELEMENT.
C     L1,M    IF L1 .LE. M THE TRANSFORMATION WILL BE CONSTRUCTED
C             TO ZERO ELEMENTS INDEXED FROM L1 THROUGH M.  IF L1
C             .GT. M THE SUBROUTINE DOES AN IDENTITY TRANSFORMATION.
C     U(),IUE,UP
C             ON ENTRY TO H1 U() CONTAINS THE PIVOT VECTOR. IUE IS
C             THE STORAGE INCREMENT BETWEEN ELEMENTS.  ON EXIT FROM
C             H1 U() AND UP CONTAIN QUANTITES DEFINING THE VECTOR U
C             OF THE HOUSEHOLDER TRANSFORMATION.  ON ENTRY TO H2 U()
C             AND UP SHOULD CONTAIN QUANTITIES PREVIOUSLY COMPUTED
C             BY H1.  THESE WILL NOT BE MODIFIED BY H2.
C     C()     ON ENTRY TO H1 OR H2 C() CONTAINS A MATRIX WHICH WILL
C             BE REGARDED AS A SET OF VECTORS TO WHICH THE HOUSEHOLDER
C             TRANSFORMATION IS TO BE APPLIED.  ON EXIT C() CONTAINS
C             THE SET OF TRANSFORMED VECTORS.
C     ICE     STORAGE INCREMENT BETWEEN ELEMENTS OF VECTORS IN C().
C     ICV     STORAGE INCREMENT BETWEEN VECTORS IN C().
C     NCV     NUMBER OF VECTORS IN C() TO BE TRANSFORMED.  IF NCV
C             .LE. 0 NO OPERATIONS WILL BE DONE ON C().
C
      SUBROUTINE H12(MODE,LPIVOT,L1,M,U,IUE,UP,C,ICE,ICV,NCV)
      DIMENSION U(IUE,M),C(1)
      DOUBLE PRECISION SM,B
      ONE=1.
C
      IF(0 .GE. LPIVOT .OR. LPIVOT .GE. L1 .OR. L1 .GT. M) RETURN
      CL=ABS(U(1,LPIVOT))
      IF(MODE .EQ. 2) GO TO 60
C
C               .....  CONSTRUCT THE TRANSFORMATION  .....
C
      DO 10 J=L1,M
  10  CL=AMAX1(ABS(U(1,J)),CL)
      IF(CL) 130,130,20
  20  CLINV=ONE/CL
      SM=(DBLE(U(1,LPIVOT))*CLINV)**2
      DO 30 J=L1,M
  30  SM=SM+(DBLE(U(1,J))*CLINV)**2
C
C               CONVERT DBLE PREC SM TO SNGL PREC SM1.
C
      SM1=SM
      CL=CL*SQRT(SM1)
      IF(U(1,LPIVOT)) 50,50,40
  40  CL=-CL
  50  UP=U(1,LPIVOT)-CL
      U(1,LPIVOT)=CL
      GO TO 70
C
C               .....  APPLY THE TRANSFORMATION I+U*(U**T)/B  TO C  .....
C
  60  IF(CL) 130,130,70
  70  IF(NCV .LE. 0) RETURN
      B=DBLE(UP)*U(1,LPIVOT)
C
C               B MUST BE NONPOSITIVE HERE.  IF B = 0., RETURN
C
      IF(B) 80,130,130
  80  B=ONE/B
      I2=1-ICV+ICE*(LPIVOT-1)
      INCR=ICE*(L1-LPIVOT)
      DO 120 J=1,NCV
      I2=I2+ICV
      I3=I2+INCR
      I4=I3
      SM=C(I2)*DBLE(UP)
      DO 90 I=L1,M
      SM=SM+C(I3)*DBLE(U(1,I))
  90  I3=I3+ICE
      IF(SM) 100,120,100
 100  SM=SM*B
      C(I2)=C(I2)+SM*DBLE(UP)
      DO 110 I=L1,M
      C(I4)=C(I4)+SM*DBLE(U(1,I))
 110  I4=I4+ICE
 120  CONTINUE
 130  RETURN
      END
C
      SUBROUTINE G1(A,B,COS,SIN,SIG)
C
C     C.L.LAWSON AND R.J.HANSON, 'SOLVING LEAST SQUARES PROBLEMS',
C     PRENTICE-HALL, 1974.
C
C     COMPUTE ORTHOGONAL ROTATION MATRIX.
C     COMPUTE..  MATRIX  (C, S) SO THAT (C, S)(A) = (SQRT(A**2+B**2))
C                        (-S,C)         (-S,C)(B)   (   0          )
C     COMPUTE SIG = SQRT(A**2+B**2)
C     SIG IS COMPUTED LAST TO ALLOW FOR THE POSSIBILITY THAT SIG
C     MAY BE IN THE SAME LOCATION AS A OR B.
C
      ZERO=0.
      ONE=1.
      IF(ABS(A) .LE. ABS(B)) GO TO 10
      XR=B/A
      YR=SQRT(ONE+XR**2)
      COS=SIGN(ONE/YR,A)
      SIN=COS*XR
      SIG=ABS(A)*YR
      RETURN
  10  IF(B) 20,30,20
  20  XR=A/B
      YR=SQRT(ONE+XR**2)
      SIN=SIGN(ONE/YR,B)
      COS=SIN*XR
      SIG=ABS(B)*YR
      RETURN
  30  SIG=ZERO
      COS=ZERO
      SIN=ONE
      RETURN
      END
C
      SUBROUTINE G2(COS,SIN,X,Y)
C
C     C.L.LAWSON AND R.J.HANSON, 'SOLVING LEAST SQUARES PROBLEMS',
C     PRENTICE-HALL, 1974.
C     APPLY THE ROTATION COMPUTED BY G1 TO (X, Y).
C
      XR=COS*X+SIN*Y
      Y=-SIN*X+COS*Y
      X=XR
      RETURN
      END
C
      FUNCTION DIFF(X,Y)
C     C.L.LAWSON AND R.J.HANSON, 'SOLVING LEAST SQUARES PROBLEMS',
C     PRENTICE-HALL, 1974.
      DIFF=X-Y
      RETURN
      END
      SUBROUTINE SVA(MDATA,ISCALE)
C     C.L.LAWSON AND R.J.HANSON, SOLVING LEAST SQUARES PROBLEMS,
C     PRENTICE-HALL, 1974.
C     SINGULAR VALUE ANALYSIS PRINTOUT.
C
C     ISCALE   SET BY USER TO 1, 2, OR 3 TO SELECT COLUMN SCALING OPTION.
C              1   SUBR. WILL USE IDENTITY SCALING AND IGNORE THE D() ARRAY.
C              2   SUBR. WILL SCALE NONZERO COLS TO HAVE UNIT EUCLIDEAN
C                  LENGTH AND WILL STORE RECIPROCAL LENGTHS OF ORIGINAL
C                  NONZERO COLS IN D().
C              3   USER SUPPLIES COL SCALE FACTORS IN D(). SUBR WILL
C                  MULT COL J BY D(J) AND REMOVE THE SCALING FROM THE
C                  SOLUTION AT THE END.
      INCLUDE 'ARSZLISA.DAT'
      COMMON/ALL/A(MDA,N)
      COMMON/REST/B(M),X(N),W(N),ZZ(M)
C     SING(3*N)
      DIMENSION NAMES(N),SING(N3),D(N)
      CHARACTER*40 IVFILE
      LOGICAL TEST
      DOUBLE PRECISION SB,DZERO
      WRITE(6,11)
  11  FORMAT(1X,'ENTER THE FILE NAME OF THE (OUPUT) V MATRIX')
      READ(5,12) IVFILE
  12  FORMAT(A)
      OPEN(UNIT=10,FILE=IVFILE,STATUS='NEW',ACCESS='SEQUENTIAL',
     +FORM='UNFORMATTED')
      DZERO=0.D0
      ONE=1.
      ZERO=0.
      IF(M .LE. 0 .OR. N .LE. 0) RETURN
      NP1=N+1
      MX1=M
      NX1=N
      WRITE(9,270)
      WRITE(9,260) MX1,NX1,MDATA
      GO TO (60,10,10), ISCALE
C
C     APPLY COLUMN SCALING TO A
C
  10  DO 50 J=1,N
      A1=D(J)
      GO TO (20,20,40), ISCALE
  20  SB=DZERO
      DO 30 I=1,M
  30  SB=SB+DBLE(A(I,J))**2
      A1=DSQRT(SB)
      IF(A1 .EQ. ZERO) A1=ONE
      A1=ONE/A1
      D(J)=A1
  40  DO 50 I=1,M
  50  A(I,J)=A(I,J)*A1
      WRITE(9,280) ISCALE,(D(J),J=1,N)
      GO TO 70
  60  CONTINUE
      WRITE(9,290)
  70  CONTINUE
C
C     OBTAIN SING. VALUE DECOMP. OF SCALED MATRIX
C
      CALL SVDRS(A,MDA,M,N,B,1,1,SING)
      CALL FUNNEL(A,MDA,N)
      CLOSE(10)
C
C
C     PRINT THE V MATRIX.
C
      CALL MFEOUT(A,MDA,N,N,NAMES,1)
      IF(ISCALE .EQ. 1) GO TO 90
C
C     REPLACE V BY D*V IN THE ARRAY A()
C
      DO 80 I=1,N
      DO 80 J=1,N
  80  A(I,J)=D(I)*A(I,J)
C
C     G NOW IN B ARRAY. V NOW IN A ARRAY.
C
C     OBTAIN SUMMARY OUTPUT.
C
  90  CONTINUE
      WRITE(9,220)
C
C     COMPUTE CUMULATIVE SUMS OF SQUARES OF COMPONENTS OF
C     G AND STORE THEM IN SING(I), I=MINMN+1,....,2*MINMN+1
C
      SB=DZERO
      MINMN=MIN0(M,N)
      MINMN1=MINMN+1
      IF(M .EQ. MINMN) GO TO 110
      DO 100 I=MINMN1,M
 100  SB=SB+DBLE(B(I))**2
 110  SING(2*MINMN+1)=SB
      DO 120 JJ=1,MINMN
      J=MINMN+1-JJ
      SB=SB+DBLE(B(J))**2
      JS=MINMN+J
 120  SING(JS)=SB
      A3=SING(MINMN+1)
      A4=SQRT(A3/FLOAT(MAX0(1,MDATA)))
      WRITE(9,230) A3,A4
C
      NSOL=0
C
C
C
      DO 160 K=1,MINMN
      IF(SING(K) .EQ. ZERO) GO TO 130
      NSOL=K
      PI=B(K)/SING(K)
      A1=ONE/SING(K)
      A2=B(K)**2
      A3=SING(MINMN1+K)
      A4=SQRT(A3/FLOAT(MAX0(1,MDATA-K)))
      TEST=SING(K) .GE. 100. .OR. SING(K) .LT. .001
      IF(TEST) WRITE(9,240) K,SING(K),PI,A1,B(K),A2,A3,A4
      IF(.NOT.TEST) WRITE(9,250) K,SING(K),PI,A1,B(K),A2,A3,A4
      GO TO 140
 130  WRITE(9,240) K,SING(K)
      PI=ZERO
 140  DO 150 I=1,N
      A(I,K)=A(I,K)*PI
 150  IF(K .GT. 1) A(I,K)=A(I,K)+A(I,K-1)
 160  CONTINUE
C
C     COMPUTE AND PRINT VALUES OF YNORM AND RNORM.
C
      WRITE(9,300)
      J=0
      YSQ=ZERO
      GO TO 180
 170  J=J+1
      YSQ=YSQ+(B(J)/SING(J))**2
 180  YNORM=SQRT(YSQ)
      JS=MINMN1+J
      RNORM=SQRT(SING(JS))
      YL=-1000.
      IF(YNORM .GT. 0.) YL=ALOG10(YNORM)
      RL=-1000.
      IF(RNORM .GT. 0.) RL=ALOG10(RNORM)
      WRITE(9,310) J,YNORM,RNORM,YL,RL
      IF(J .LT. NSOL) GO TO 170
C
C     COMPUTE VALUES OF XNORM AND RNORM FOR A SEQUENCE OF VALUES OF
C     THE LEVENBERG-MARQUARDT PARAMETER.
C
      IF(SING(1) .EQ. ZERO) GO TO 210
      EL=ALOG10(SING(1))+ONE
      EL2=ALOG10(SING(NSOL))-ONE
      DEL=(EL2-EL)/20.
      TEN=10.
      ALN10=ALOG(TEN)
      WRITE(9,320)
      WRITE(9,321)
      DO 200 IE=1,21
C     COMPUTE ALAMB=10.**EL
      ALAMB=EXP(ALN10*EL)
      YS=0.
      JS=MINMN1+NSOL
      RS=SING(JS)
      DO 190 I=1,MINMN
      SL=SING(I)**2+ALAMB**2
      YS=YS+(B(I)*SING(I)/SL)**2
      RS=RS+(B(I)*(ALAMB**2)/SL)**2
 190  CONTINUE
      YNORM=SQRT(YS)
      RNORM=SQRT(RS)
      RL=-1000.
      IF(RNORM .GT. ZERO) RL=ALOG10(RNORM)
      YL=-1000.
      IF(YNORM .GT. ZERO) YL=ALOG10(YNORM)
      WRITE(9,330) ALAMB,YNORM,RNORM,EL,YL,RL
      EL=EL+DEL
 200  CONTINUE
C
C     PRINT CANDIDATE SOLUTIONS.
C
 210  IF(NSOL .GE. 1) CALL MFEOUT(A,MDA,N,NSOL,NAMES,2)
      RETURN
 220  FORMAT (42H  INDEX  SING. VALUE       P COEF         ,47HRECIP. S.
     1V.            G COEF            G**2  ,32H        C.S.S.      N.S.
     2R.C.S.S.)
 230  FORMAT (1H ,4X,1H0,84X,1PE14.4,2X,1PE14.4)
 240  FORMAT (1H ,I5,E12.4,1P(E14.4,4X,E14.4,4X,E14.4,4X,E14.4,4X,E14.4,
     12X,E14.4))
 250  FORMAT (1H ,I5,F12.4,1P(E14.4,4X,E14.4,4X,E14.4,4X,E14.4,4X,E14.4,
     12X,E14.4))
 260  FORMAT (5H M = ,I6,8H,   N = ,I4,12H,   MDATA = ,I8)
 270  FORMAT (45H SINGULAR VALUE ANALYSIS OF THE LEAST SQUARES,42H PROBL
     1EM,  A*X=B,  SCALED AS  (A*D)*Y=B  .)
 280  FORMAT (19H SCALING OPTION NO.,I2,18H.  D IS A DIAGONAL,46H MATRIX
     1 WITH THE FOLLOWING DIAGONAL ELEMENTS../(5X,10E12.4))
 290  FORMAT (50H SCALING OPTION NO. 1.   D IS THE IDENTITY MATRIX./1X)
 300  FORMAT (6H INDEX,13X,28H         YNORM         RNORM,14X,28H  LOG1
     10(YNORM)  LOG10(RNORM)/1X)
 310  FORMAT (1H ,I4,14X,2E14.5,14X,2F14.5)
 320  FORMAT (54H NORMS OF SOLUTION AND RESIDUAL VECTORS FOR A RANGE OF,
     144H VALUES OF THE LEVENBERG-MARQUARDT PARAMETER,9H, LAMBDA.)
 321  FORMAT (/1H ,4X,42H        LAMBDA         TNORM         RNORM,
     142H LOG10(LAMBDA)  LOG10(YNORM)  LOG10(RNORM))   
 330  FORMAT (5X,3E14.5,3F14.5)
      END
C
C     SUBROUTINE SVDRS(A,MDA,MM,NN,B,MDB,NB,S)
C     C.L.LAWSON AND R.J.HANSON, SOLVING LEAST SQUARES PROBLEMS,
C     PRENTICE-HALL,1974.
C     SINGULAR VALUE DECOMPOSITION ALSO TREATING RIGHT SIDE VECTOR.
C
C     THE ARRAY S OCCUPIES 3*N CELLS.
C     A OCCUPIES M*N CELLS
C     B OCCUPIES M*NB CELLS
C
C     SPECIAL SINGULAR VALUE DECOMPOSITION SUBROUTINE
C     WE HAVE THE M X N MATRIX A AND THE SYSTEM A*X=B TO SOLVE.
C     EITHER M .GE. N OR M .LT. N IS PERMITTED.
C                      THE SINGULAR VALUE DECOMPOSITION
C     A = U*S*V**(T) IS MADE IN SUCH A WAY THAT ONE GETS
C        (1) THE MATRIX V IN THE FIRST N ROWS AND COLUMNS OF A.
C         (2) THE DIAGONAL MATRIX OF ORDERED SINGULAR VALUES IN
C            THE FIRST N CELLS OF THE ARRAY S(IP), IP .GE. 3*N.
C        (3) THE MATRIX PRODUCT U**(T)*B=G GETS PLACED BACK IN B.
C        (4) THE USER MUST COMPLETE THE SOLUTION AND DO HIS OWN
C            SINGULAR VALUE ANALYSIS.
C
C     GIVE SPECIAL
C     TREATMENT TO ROWS AND COLUMNS WHICH ARE ENTIRELY ZERO. THIS
C     CAUSES CERTAIN ZERO SING. VALS. TO APPEAR AS EXACT ZEROS RATHER
C     THAN AS ABOUT ETA TIMES THE LARGEST SING. VAL.  IT SIMILARLY
C     CLEANS UP THE ASSOCIATED COLUMNS OF U AND V.
C     METHOD...
C      1. EXCHANGE COLS OF A TO PACK NONZERO COLS TO THE LEFT.
C         SET N = NO. OF NONZERO COLS.
C         USE LOCATIONS A(1,NN),A(1,NN-1),...,A(1,N+1) TO RECORD THE
C         COL PERMUTATIONS.
C      2. EXCHANGE ROWS OF A TO PACK NONZERO ROWS TO THE TOP.
C         QUIT PACKING IF FIND N NONZERO ROWS.  MAKE SAME ROW EXCHANGES
C         IN B.  SET M SO THAT ALL NONZERO ROWS OF THE PERMUTED A
C         ARE IN FIRST M ROWS.  IF M .LE. N THEN ALL M ROWS ARE
C         NONZERO.  IF M .GT. N THEN THE FIRST N ROWS ARE KNOWN
C         TO BE NONZERO, AND ROWS N+1 THRU M MAY BE ZERO OR NONZERO.
C      3. APPLY ORIGINAL ALGORITHM TO THE M BY N PROBLEM.
C      4. MOVE PERMUTATION RECORD FROM A(,) TO S(I),I=N+1,...,NN.
C      5. BUILD V UP FROM N BY N TO NN BY NN BY PLACING ONES ON
C         THE DIAGONAL AND ZEROS ELSEWHERE.  THIS IS ONLY PARTLY DONE
C         EXPLICITLY.  IT IS COMPLETED DURING STEP 6.
C      6. EXCHANGE ROWS OF V TO COMPENSATE FOR COL EXCHANGES OF STEP 2.
C      7. PLACE ZEROS IN S(I),I=N+1,NN TO REPRESENT ZERO SING VALS.
C
      SUBROUTINE SVDRS(A,MDA,MM,NN,B,MDB,NB,S)
      DIMENSION A(MDA,NN),B(MDB,NB),S(NN,3)
      ZERO=0.
      ONE=1.
C
C                     BEGIN...SPECIAL FOR ZERO ROWS AND COLS.
C                     PACK THE NONZERO COLS TO THE LEFT
C
      N=NN
      IF(N .LE. 0 .OR. MM .LE. 0) RETURN
      J=N
  10  CONTINUE
      DO 20 I=1,MM
      IF(A(I,J)) 50,20,50
  20  CONTINUE
C
C     COL J IS ZERO. EXCHANGE IT WITH COL N.
C
      IF(J .EQ. N) GO TO 40
      DO 30 I=1,MM
  30  A(I,J)=A(I,N)
  40  CONTINUE
      A(1,N)=J
      N=N-1
  50  CONTINUE
      J=J-1
      IF(J .GE. 1) GO TO 10
C                            IF N=0 THEN A IS ENTIRELY ZERO AND SVD
C                            COMPUTATION CAN BE SKIPPED.
      NS=0
      IF(N .EQ. 0) GO TO 240
C                            PACK NONZERO ROWS TO THE TOP
C                            QUIT PACKING IF FIND N NONZERO ROWS.
      I=1
      M=MM
  60  IF(I .GT. N .OR. I .GE. M) GO TO 150
      IF(A(I,I)) 90,70,90
  70  DO 80 J=1,N
      IF(A(I,J)) 90,80,90
  80  CONTINUE
      GO TO 100
  90  I=I+1
      GO TO 60
C                            ROW I IS ZERO
C                            EXCHANGE ROWS I AND M
 100  IF(NB .LE. 0) GO TO 115
      DO 110 J=1,NB
      T=B(I,J)
      B(I,J)=B(M,J)
 110  B(M,J)=T
 115  DO 120 J=1,N
 120  A(I,J)=A(M,J)
      IF(M .GT. N) GO TO 140
      DO 130 J=1,N
 130  A(M,J)=ZERO
 140  CONTINUE
C                             EXCHANGE IS FINISHED.
      M=M-1
      GO TO 60
C
 150  CONTINUE
C                             END.. SPECIAL FOR ZERO ROWS AND COLUMNS
C                             BEGIN.. SVD ALGORITHM.
C     METHOD..
C     (1)     REDUCE THE MATRIX TO UPPER BIDIAGONAL FORM WITH
C     HOUSEHOLDER TRANSFORMATIONS.
C          H(N)...H(1)AQ(1)...Q(N-2) = (D**T,0)**T
C     WHERE D IS UPPER BIDIAGONAL.
C
C     (2)     APPLY H(N)...H(1) TO B.  HERE H(N)...H(1)*B REPLACES B
C     IN STORAGE.
C
C     (3)     THE MATRIX PRODUCT W= Q(1)...Q(N-2) OVERWRITES THE FIRST
C     N ROWS OF A IN STORAGE.
C
C     (4)     AN SVD FOR D IS COMPUTED.  HERE K ROTATIONS RI AND PI ARE
C     COMPUTED SO THAT
C          RK...R1*D*P1**(T)...PK**(T) = DIAG(S1,...,SM)
C     TO WORKING ACCURACY.  THE SI ARE NONNEGATIVE AND NONINCREASING.
C     HERE RK...R1*B OVERWRITES B IN STORAGE WHILE
C     A*P1**(T)...PK**(T) OVERWRITES A IN STORAGE.
C
C     (5)     IT FOLLOWS THAT, WITH THE PROPER DEFINITIONS,
C     U**(T)*B OVERWRITES B, WHILE V OVERWRITES THE FIRST N ROW AND
C     COLUMNS OF A.
C
      L=MIN0(M,N)
C             THE FOLLOWING LOOP REDUCES A TO UPPER BIDIAGONAL AND
C             ALSO APPLIES THE PREMULTIPLYING TRANSFORMATIONS TO B.
C
      DO 170 J=1,L
      IF(J .GE. M) GO TO 160
      CALL H12(1,J,J+1,M,A(1,J),1,T,A(1,J+1),1,MDA,N-J)
      CALL H12(2,J,J+1,M,A(1,J),1,T,B,1,MDB,NB)
 160  IF(J .GE. N-1) GO TO 170
      CALL H12(1,J+1,J+2,N,A(J,1),MDA,S(J,3),A(J+1,1),MDA,1,M-J)
 170  CONTINUE
C
C     COPY THE BIDIAGONAL MATRIX INTO THE ARRAY S() FOR QRBD.
C
      IF(N .EQ. 1) GO TO 190
      DO 180 J=2,N
      S(J,1)=A(J,J)
 180  S(J,2)=A(J-1,J)
 190  S(1,1)=A(1,1)
C
      NS=N
      IF(M .GE. N) GO TO 200
      NS=M+1
      S(NS,1)=ZERO
      S(NS,2)=A(M,M+1)
 200  CONTINUE
C
C     CONSTRUCT THE EXPLICIT N BY N PRODUCT MATRIX, W=Q1*Q2*...*QL*I
C     IN THE ARRAY A().
C
      DO 230 K=1,N
      I=N+1-K
      IF(I .GE. N-1) GO TO 210
      CALL H12(2,I+1,I+2,N,A(I,1),MDA,S(I,3),A(1,I+1),1,MDA,N-I)
 210  DO 220 J=1,N
 220  A(I,J)=ZERO
 230  A(I,I)=ONE
C
C     COMPUTE THE SVD OF THE BIDIAGONAL MATRIX.
C
      CALL QRBD(IPASS,S(1,1),S(1,2),NS,A,MDA,N,B,MDB,NB)
C
      GO TO (240,310),IPASS
 240  CONTINUE
      IF(NS .GE. N) GO TO 260
      NSP1=NS+1
      DO 250 J=NSP1,N
 250  S(J,1)=ZERO
 260  CONTINUE
      IF(N .EQ. NN) RETURN
      NP1=N+1
C                    MOVE RECORD OF PERMUTATIONS AND STORE ZEROS.
      DO 280 J=NP1,NN
      S(J,1)=A(1,J)
      DO 270 I=1,N
 270  A(I,J)=ZERO
 280  CONTINUE
C                  PERMUTE ROWS AND SET ZERO SINGULAR VALUES.
      DO 300 K=NP1,NN
      I=S(K,1)
      S(K,1)=ZERO
      DO 290 J=1,NN
      A(K,J)=A(I,J)
 290  A(I,J)=ZERO
      A(I,K)=ONE
 300  CONTINUE
C                  END.. SPECIAL FOR ZERO ROWS AND COLUMNS.
      RETURN
 310  WRITE(9,320)
      STOP
 320  FORMAT(49H CONVERGENCE FAILURE IN QR BIDIAGONAL SVD ROUTINE)
      END
C
C     SUBROUTINE QRBD(IPASS,Q,E,NN,V,MDV,NRV,C,MDC,NCC)
C     C.L.LAWSON AND R.J.HANSON, SOLVING LEAST SQUARES PROBLEMS,
C     PRENTICE-HALL, 1974.
C         QR ALGORITHM FOR SINGULAR VALUES OF A BIDIAGONAL MATRIX.
C
C     THE BIDIAGONAL MATRIX
C
C                       (Q1,E2,0...    )
C                       (   Q2,E3,0... )
C               D=      (       .      )
C                       (         .   0)
C                       (           .EN)
C                       (          0,QN)
C
C     IS PRE AND POST MULTIPLIED BY ELEMENTARY ROTATION MATRICES
C     RI AND PI SO THAT
C
C         RK...R1*D*P1**(T)...PK**(T) = DIAG(S1,...,SN)
C
C     TO WITHIN WORKING ACCURACY.
C
C     1. EI AND QI OCCUPY E(I) AND Q(I) AS INPUT.
C     2. RM...R11*C REPLACES 'C' IN STORAGE AS OUTPUT.
C     3. V*P1**(T)...PM**(T) REPLACES 'V' IN STORAGE AS OUTPUT.
C     4. SI OCCUPIES Q(I) AS OUTPUT.
C     5. THE SI'S ARE NONINCREASING AND NONNEGATIVE.
C
C     THIS CODE IS BASED ON THE PAPER AND 'ALGOL' CODE..
C     REF..
C     REINSCH,C.H. AND GOLUB,G.H. 'SINGULAR VALUE DECOMPOSITION
C     AND LEAST SQUARES SOLUTIONS' (NUMER. MATH.) VOL. 14, 1970.
C
      SUBROUTINE QRBD(IPASS,Q,E,NN,V,MDV,NRV,C,MDC,NCC)
      LOGICAL WNTV,HAVERS,FAIL
      DIMENSION Q(NN),E(NN),V(MDV,NN),C(MDC,NCC)
      ZERO=0.
      ONE=1.
      TWO=2.
C
      N=NN
      IPASS=1
      IF(N .LE. 0) RETURN
      N10=10*N
      WNTV=NRV.GT.0
      HAVERS=NCC.GT.0
      FAIL=.FALSE.
      NQRS=0
      E(1)=ZERO
      DNORM=ZERO
      DO 10 J=1,N
  10  DNORM=AMAX1(ABS(Q(J))+ABS(E(J)),DNORM)
      DO 200 KK=1,N
      K=N+1-KK
C
C     TEST FOR SPLITTING OR RANK DEFICIENCIES..
C     FIRST MAKE TEST FOR LAST DIAGONAL TERM, Q(K), BEING SMALL.
  20  IF(K .EQ. 1) GO TO 50
      IF(DIFF(DNORM+Q(K),DNORM)) 50,25,50
C
C     SINCE Q(K) IS SMALL WE WILL MAKE A SPECIAL PASS TO
C     TRANSFORM E(K) TO ZERO.
C
  25  CS=ZERO
      SN=-ONE
      DO 40 II=2,K
      I=K+1-II
      F=-SN*E(I+1)
      E(I+1)=CS*E(I+1)
      CALL G1(Q(I),F,CS,SN,Q(I))
C     TRANSFORMATION CONSTRUCTED TO ZERO POSITION (I,K).
C
      IF(.NOT.WNTV) GO TO 40
      DO 30 J=1,NRV
  30  CALL G2(CS,SN,V(J,I),V(J,K))
C     ACCUMULATE RT. TRANSFORMATIONS IN V.
C
  40  CONTINUE
C
C     THE MATRIX IS NOW BIDIAGONAL, AND OF LOWER ORDER
C     SINCE E(K) .EQ. ZERO..
C
  50  DO 60 LL=1,K
      L=K+1-LL
      IF(DIFF(DNORM+E(L),DNORM)) 55,100,55
  55  IF(DIFF(DNORM+Q(L-1),DNORM)) 60,70,60
  60  CONTINUE
C     THIS LOOP CAN'T COMPLETE SINCE E(1) = ZERO.
C
      GO TO 100
C
C     CANCELLATION OF E(L), L .GT. 1.
  70  CS=ZERO
      SN=-ONE
      DO 90 I=L,K
      F=-SN*E(I)
      E(I)=CS*E(I)
      IF(DIFF(DNORM+F,DNORM)) 75,100,75
  75  CALL G1(Q(I),F,CS,SN,Q(I))
      IF(.NOT.HAVERS) GO TO 90
      DO 80 J=1,NCC
  80  CALL G2(CS,SN,C(I,J),C(L-1,J))
  90  CONTINUE
C
C     TEST FOR CONVERGENCE..
 100  Z=Q(K)
      IF(L .EQ. K) GO TO 170
C
C     SHIFT FROM BOTTOM 2 BY 2 MINOR OF B**(T)*B.
      X=Q(L)
      Y=Q(K-1)
      G=E(K-1)
      H=E(K)
      F=((Y-Z)*(Y+Z)+(G-H)*(G+H))/(TWO*H*Y)
      G=SQRT(ONE+F**2)
      IF(F .LT. ZERO) GO TO 110
      T=F+G
      GO TO 120
 110  T=F-G
 120  F=((X-Z)*(X+Z)+H*(Y/T-H))/X
C
C     NEXT QR SWEEP..
      CS=ONE
      SN=ONE
      LP1=L+1
      DO 160 I=LP1,K
      G=E(I)
      Y=Q(I)
      H=SN*G
      G=CS*G
      CALL G1(F,H,CS,SN,E(I-1))
      F=X*CS+G*SN
      G=-X*SN+G*CS
      H=Y*SN
      Y=Y*CS
      IF(.NOT.WNTV) GO TO 140
C
C     ACCUMULATE ROTATIONS (FROM THE RIGHT) IN 'V'
      DO 130 J=1,NRV
 130  CALL G2(CS,SN,V(J,I-1),V(J,I))
 140  CALL G1(F,H,CS,SN,Q(I-1))
      F=CS*G+SN*Y
      X=-SN*G+CS*Y
      IF(.NOT.HAVERS) GO TO 160
      DO 150 J=1,NCC
 150  CALL G2(CS,SN,C(I-1,J),C(I,J))
C     APPLY ROTATIONS FROM THE LEFT TO
C     RIGHT HAND SIDES IN 'C'..
C
 160  CONTINUE
      E(L)=ZERO
      E(K)=F
      Q(K)=X
      NQRS=NQRS+1
      IF(NQRS .LE. N10) GO TO 20
C     RETURN TO 'TEST FOR SPLITTING'.
C
      FAIL=.TRUE.
C
C     CUTOFF FOR CONVERGENCE FAILURE. 'NQRS' WILL BE 2*N USUALLY.
 170  IF(Z .GE. ZERO) GO TO 190
      Q(K)=-Z
      IF(.NOT.WNTV) GO TO 190
      DO 180 J=1,NRV
 180  V(J,K)=-V(J,K)
 190  CONTINUE
C     CONVERGENCE. Q(K) IS MADE NONNEGATIVE..
C
 200  CONTINUE
      IF(N .EQ. 1) RETURN
      DO 210 I=2,N
      IF(Q(I) .GT. Q(I-1)) GO TO 220
 210  CONTINUE
      IF(FAIL) IPASS=2
      RETURN
C
C     EVERY SINGULAR VALUE IS IN ORDER..
 220  DO 270 I=2,N
      T=Q(I-1)
      K=I-1
      DO 230 J=I,N
      IF(T .GE. Q(J)) GO TO 230
      T=Q(J)
      K=J
 230  CONTINUE
      IF(K .EQ. I-1) GO TO 270
      Q(K)=Q(I-1)
      Q(I-1)=T
      IF(.NOT.HAVERS) GO TO 250
      DO 240 J=1,NCC
      T=C(I-1,J)
      C(I-1,J)=C(K,J)
 240  C(K,J)=T
 250  IF(.NOT.WNTV) GO TO 270
      DO 260 J=1,NRV
      T=V(J,I-1)
      V(J,I-1)=V(J,K)
 260  V(J,K)=T
 270  CONTINUE
C     END OF ORDERING ALGORITHM.
C
      IF(FAIL) IPASS=2
      RETURN
      END
C
      SUBROUTINE MFEOUT(A,MDA,M,N,NAMES,MODE)
C     C.L.LAWSON AND R.J.HANSON, SOLVING LEAST SQUARES PROBLEMS,
C     PRENTICE-HALL, 1974.
C         SUBROUTINE FOR MATRIX OUTPUT WITH LABELING.
C
C     A( )     MATRIX TO BE OUTPUT
C              MDA   FIRST DIMENSION OF A ARRAY
C              M     NO. OF ROWS IN A MATRIX
C              N     NO. OF COLS IN A MATRIX
C     NAMES()  ARRAY OF NAMES.  IF NAMES(1) = 1H , THE REST
C              OF THE NAMES() ARRAY WILL BE IGNORED.
C     MODE     =1 FOR 4P8F15.0 FORMAT FOR V MATRIX.
C              =2 FOR 8E15.8   FORMAT FOR CANDIDATE SOLUTIONS.
C
      DIMENSION A(MDA,N)
      INTEGER NAMES(M)
      INTEGER*4 IHEAD(2)
      LOGICAL NOTBLK
      DATA MAXCOL/7/,IBLANK/1H /,IHEAD(1)/4H COL/,IHEAD(2)/4HSOLN/
C
      IF(M .LE. 0 .OR. N .LE. 0) RETURN
      NOTBLK=NAMES(1).NE.IBLANK
C
      IF(MODE .EQ. 2) GO TO 10
      WRITE(9,70)
      GO TO 20
  10  WRITE(9,80)
  20  CONTINUE
C
      NBLOCK=N/MAXCOL
      LAST=N-NBLOCK*MAXCOL
      NCOL=MAXCOL
      J1=1
C
C                           MAIN LOOP STARTS HERE
C
  30  IF(NBLOCK .GT. 0) GO TO 40
      IF(LAST .LE. 0) RETURN
      NCOL=LAST
      LAST=0
C
  40  J2=J1+NCOL-1
      WRITE(9,90) (IHEAD(MODE),J,J=J1,J2)
C
      DO 60 I=1,M
      NAME=IBLANK
      IF(NOTBLK) NAME=NAMES(I)
C
      IF(MODE .EQ. 2) GO TO 50
      WRITE(9,100) I,(A(I,J),J=J1,J2)
      GO TO 60
  50  WRITE(9,110) I,(A(I,J),J=J1,J2)
  60  CONTINUE
C
      J1=J1+MAXCOL
      NBLOCK=NBLOCK-1
      GO TO 30
C
  70  FORMAT (45H V-MATRIX OF THE SINGULAR VALUE DECOMPOSITION,
     1 8H OF A*D./47H (ELEMENTS OF V SCALED UP BY A FACTOR OF 10**4))
  80  FORMAT (35H SEQUENCE OF CANDIDATE SOLUTIONS, X)
  90  FORMAT (1H ,11X,8(6X,A4,I4,1X)/1X)
 100  FORMAT (1X,I3,6X,4P8F15.4)
 110  FORMAT (1X,I3,8X,8E15.6)
      END
      SUBROUTINE FUNNEL(A,MDA,N)
      DIMENSION A(MDA,N),V(900)
      DO 10 I=1,N
      DO 20 J=1,N
  20  V(J)=A(I,J)
      WRITE(10) (V(K),K=1,N)
  10  CONTINUE
      RETURN
      END
      SUBROUTINE CONSTR(MSTART,B,NSUBF,JW,NREC,NMECH,SYN)
C
C     NMECH...NUMBER OF DIFFERENT MECHANISMS PER SUBFAULT (1 OR 2)
C     NREC....TOTAL NUMBER OF RECORDS IN INVERSION
C     NSUBF...TOTAL NUMBER OF SUBFAULTS
C     MSTART..NUMBER OF ROWS IN 'A' MATRIX UPON ENTERING SUBROUTINE
C     JW......NUMBER OF TIME WINDOWS
C     M.......NUMBER OF ROWS IN 'A' MATRIX UPON EXITING SUBROUTINE
C     N.......NUMBER OF COLUMNS IN 'A' MATRIX
C
      INCLUDE 'ARSZLISA.DAT'
      COMMON/ALL/A(M,N)
      DIMENSION B(M),SYN(5000)
      IC=MSTART+1
      WRITE(6,612)
 612  FORMAT(1X,'DO YOU WANT TO ADD ON SMOOTHING OR MINIMIZATION',/,
     +1X,'CONSTRAINTS TO THE DISLOCATION AMPLITUDE, 1=YES 0=NO')
      READ(5,*) IDLS
      IF(IDLS .EQ. 0) GO TO 46
      WRITE(6,613)
 613  FORMAT('FIRST ORDER DIFFERENCE SMOOTHING OF DISLOCATION',/,
     +1X,'AMPLITUDES, 1=YES 0=NO')
      READ(5,*) IFOD
      IF(IFOD .EQ. 0) GO TO 47
      WRITE(6,614)
 614  FORMAT(1X,'HOW MANY SUBFAULTS ARE THERE DOWN THE DIP AND',/,
     +1X,'ALONG THE FAULT STRIKE')
      READ(5,*) NSUBV,NSUBH
      WRITE(6,616)
 616  FORMAT(1X,'ENTER FIRST ORDER DIFFERENCE SMOOTHING WEIGHT')
      READ(5,*) WTSMH
  47  WRITE(6,619)
 619  FORMAT(1X,'MINIMIZATION OF DISLOCATION AMPLITUDES',/,
     +1X,'1=YES, 0=NO')
      READ(5,*) IMIN
      IF(IMIN .EQ. 0) GO TO 46
      WRITE(6,620)
 620  FORMAT(1X,'ENTER DISLOCATION MINIMIZATION WEIGHT')
      READ(5,*) WTMIN
  46  CONTINUE
      WRITE(6,6)
  6   FORMAT(1X,'DO YOU WANT RUPTURE TIME CONSTRAINT EQUATIONS',/,
     +1X,'ADDED, 1=YES 0=NO')
      READ(5,*) IRUPEQ
      IF(IRUPEQ .EQ. 0) GO TO 7
      WRITE(6,8)
  8   FORMAT(1X,'FIRST ORDER DIFFERENCE CONSTRAINT ON RUPTURE',/,
     +1X,'TIMES, 1=YES 0=NO')
      READ(5,*) IRUPDF
      IF(IRUPDF .EQ. 0) GO TO 9
      WRITE(6,12)
 12   FORMAT(1X,'HOW MANY SUBFAULTS ARE THERE DOWN THE DIP AND',/,
     +1X,'ALONG THE FAULT STRIKE')
      READ(5,*) NSUBV,NSUBH
      NSUBFF=NSUBV*NSUBH
      IF(NSUBFF .NE. NSUBF) THEN
      WRITE(6,42)
 42   FORMAT(1X,'WRONG NUMBER OF SUBFAULTS')
      STOP
      ENDIF
      WRITE(6,10)
 10   FORMAT(1X,'ENTER FIRST ORDER DIFFERENCE WEIGHT')
      READ(5,*) RUPDFW
  9   WRITE(6,11)
 11   FORMAT(1X,'MINIMIZATION CONSTRAINT ON RUPTURE TIMES',/,
     +1X,'1=YES 0=NO')
      READ(5,*) IRUPMN
      IF(IRUPMN .EQ. 0) GO TO 7
      WRITE(6,13)
 13   FORMAT(1X,'ENTER MINIMIZATION WEIGHT')
      READ(5,*) RUPMNW
  7   WRITE(6,14)
 14   FORMAT(1X,'DO YOU WANT TRIGGER TIME CONSTRAINT EQUATIONS',/,
     +1X,'ADDED, 1=YES 0=NO')
      READ(5,*) ITRGEQ
      IF(ITRGEQ .EQ. 0) GO TO 15
      WRITE(6,16)
 16   FORMAT(1X,'CONSTRAINT WILL BE ADDED TO HAVE EQUAL TRIGGER',/,
     +1X,'TIMES FOR ALL COMPONENTS OF A GIVEN STATION. ENTER',/,
     +1X,'WEIGHT AND NUMBER OF COMPONENTS (OR RECORDS) PER STATION')     
      READ(5,*) TRGW,NCOMP
      WRITE(6,17)
 17   FORMAT(1X,'MINIMIZATION CONSTRAINT ON TRIGGER TIMES, 1=YES',/,
     +1X,'0=NO')
      READ(5,*) ITRGMN
      IF(ITRGMN .EQ. 0) GO TO 15
      WRITE(6,18)
 18   FORMAT(1X,'ENTER MINIMIZATION WEIGHT')
      READ(5,*) TRGMNW
 15   NN=NSUBF*NMECH
      IF(IDLS .EQ. 0) GO TO 121
      IF(IMIN .EQ. 0) GO TO 72
      NN=NSUBF*NMECH*JW
      IDENT=1
      DO 73 K=1,NN
      DO 74 I=1,N
      SYN(I)=0.
  74  IF(I .EQ. IDENT) SYN(I)=WTMIN
      DO 84 I=1,N
  84  A(IC,I)=SYN(I)
      IC=IC+1
      IDENT=IDENT+1
  73  CONTINUE
  72  IF(IFOD .EQ. 0) GO TO 121
      MM=(NSUBF-NSUBV)*NMECH*JW
      IF(MM .EQ. 0) GO TO 75
      NUMZER=NSUBV*NMECH*JW-1
      ILOC1=1
      ILOC2=ILOC1+NUMZER+1
      DO 76 K=1,MM
      DO 77 I=1,N
      SYN(I)=0.
      IF(I .EQ. ILOC1) SYN(I)=WTSMH
  77  IF(I .EQ. ILOC2) SYN(I)=-WTSMH
      DO 85 I=1,N
  85  A(IC,I)=SYN(I)
      IC=IC+1
      ILOC1=ILOC1+1
      ILOC2=ILOC2+1
  76  CONTINUE
  75  MM=(NSUBF-NSUBH)*NMECH*JW
      IF(MM .EQ. 0) GO TO 121
      NUMZER=NMECH*JW-1
      ILOC1=1
      ILOC2=ILOC1+NUMZER+1
      ICOUNT=0
      ISTEP=NMECH*JW*NSUBV-NMECH*JW
      DO 79 K=1,MM
      ICOUNT=ICOUNT+1
      DO 81 I=1,N
      SYN(I)=0.
      IF(I .EQ. ILOC1) SYN(I)=WTSMH
  81  IF(I .EQ. ILOC2) SYN(I)=-WTSMH
      DO 86 I=1,N
  86  A(IC,I)=SYN(I)
      IC=IC+1
      ILOC1=ILOC1+1
      ILOC2=ILOC2+1
      IF(ICOUNT .EQ. ISTEP) GO TO 82
      GO TO 83
  82  ILOC1=ILOC1+NMECH*JW
      ILOC2=ILOC2+NMECH*JW
      ICOUNT=0
  83  CONTINUE
  79  CONTINUE
 121  CONTINUE
      IF(IRUPEQ .EQ. 0) GO TO 20
      IF(IRUPDF .EQ. 0) GO TO 21
      MM=NSUBF-NSUBV
      IF(MM .EQ. 0) GO TO 55
      NUMZER=NSUBV-1
      ILOC1=NN+1
      ILOC2=ILOC1+NUMZER+1
      DO 56 K=1,MM
      DO 57 I=1,N
      SYN(I)=0.
      IF(I .EQ. ILOC1) SYN(I)=RUPDFW
 57   IF(I .EQ. ILOC2) SYN(I)=-RUPDFW
      DO 19 I=1,N
 19   A(IC,I)=SYN(I)
      ILOC1=ILOC1+1
      ILOC2=ILOC2+1
 56   IC=IC+1
 55   MM=NSUBF-NSUBH
      IF(MM .EQ. 0) GO TO 21
      NUMZER=0
      ILOC1=NN+1
      ILOC2=ILOC1+NUMZER+1
      ICOUNT=0
      ISTEP=NSUBV-1
      DO 59 K=1,MM
      ICOUNT=ICOUNT+1
      DO 61 I=1,N
      SYN(I)=0.
      IF(I .EQ. ILOC1) SYN(I)=RUPDFW
 61   IF(I .EQ. ILOC2) SYN(I)=-RUPDFW
      DO 22 I=1,N
 22   A(IC,I)=SYN(I)
      ILOC1=ILOC1+1
      ILOC2=ILOC2+1
      IF(ICOUNT .EQ. ISTEP) GO TO 62
      GO TO 63
 62   ILOC1=ILOC1+1
      ILOC2=ILOC2+1
      ICOUNT=0
 63   CONTINUE
 59   IC=IC+1
 21   IF(IRUPMN .EQ. 0) GO TO 20
      IDENT=NN+1
      DO 53 K=1,NSUBF
      DO 54 I=1,N
      SYN(I)=0.
 54   IF(I .EQ. IDENT) SYN(I)=RUPMNW
      DO 23 I=1,N
 23   A(IC,I)=SYN(I)
      IDENT=IDENT+1
 53   IC=IC+1
 20   IF(ITRGEQ .EQ. 0) GO TO 25
      ILOC1=NN+NSUBF+1
      ILOC2=ILOC1+1
      IF(NCOMP .EQ. 1) GO TO 26
      IF(NCOMP .EQ. 3) GO TO 27
      NUMC=NREC/2
      DO 28 K=1,NUMC
      DO 29 I=1,N
      SYN(I)=0.
      IF(I .EQ. ILOC1) SYN(I)=TRGW
 29   IF(I .EQ. ILOC2) SYN(I)=-TRGW
      DO 30 I=1,N
 30   A(IC,I)=SYN(I)
      ILOC1=ILOC1+2
      ILOC2=ILOC2+2
 28   IC=IC+1
      GO TO 26
 27   NUMC=NREC
      ICOUNT=0
      DO 31 K=1,NUMC
      DO 32 I=1,N
      SYN(I)=0.
      IF(I .EQ. ILOC1) SYN(I)=TRGW
 32   IF(I .EQ. ILOC2) SYN(I)=-TRGW
      DO 33 I=1,N
 33   A(IC,I)=SYN(I)
      ICOUNT=ICOUNT+1
      IC=IC+1
      IF(ICOUNT .EQ. 1) ILOC2=ILOC2+1
      IF(ICOUNT .EQ. 2) ILOC1=ILOC1+1
      IF(ICOUNT .EQ. 3) THEN
      ILOC1=ILOC1+2
      ILOC2=ILOC2+2
      ICOUNT=0
      ENDIF
 31   CONTINUE
 26   IF(ITRGMN .EQ. 0) GO TO 25
      IDENT=NN+NSUBF+1
      DO 34 K=1,NREC
      DO 35 I=1,N
      SYN(I)=0.
 35   IF(I .EQ. IDENT) SYN(I)=TRGMNW
      DO 36 I=1,N
 36   A(IC,I)=SYN(I)
      IDENT=IDENT+1
 34   IC=IC+1
 25   MEND=IC-1
      NROWAD=MEND-MSTART
      WRITE(6,40) NROWAD
 40   FORMAT(1X,'THE NUMBER OF ROWS ADDED TO THE A MATRIX IN',/,
     +1X,'SUBROUTINE CONSTR IS ',I6)
      WRITE(6,37) MEND
 37   FORMAT(1X,'THE TOTAL NUMBER OF ROWS IN THE A MATRIX IS ',I6)
      IF(MEND .NE. M) THEN
      WRITE(6,38) M
 38   FORMAT(1X,'THE DIMENSION OF THE A MATRIX, ',I6,' ,IS NOT',/,
     +1X,'EQUAL TO THE TOTAL NUMBER OF ROWS....STOP')
      STOP
      ENDIF
      IC=MSTART+1
      DO 39 I=IC,MEND
 39   B(I)=0.
      RETURN
      END
