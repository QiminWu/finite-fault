C
C   PROGRAM LISA ... NONNEGATIVE LEAST SQUARES INVERSION
C
C	This version calculates and uses an automatically-generated spatial-smoothing 
C	and moment-minimization weight to constrain the NNLS inverse for rapid analysis.
C	The smoothing weight (smwt) is calculated from the average (AVGA) absolute value
C	of the elements in the A matrix using the simple relation: smwt = 90.*AVGA
C	Source parameters are read from pre-existing PARAM.DAT file.
C	cm/nov2011
C
      INCLUDE 'ARSZLISA.DAT'
      COMMON/ALL/A(MDA,N)
      COMMON/REST/B(M),X(N),W(N),ZZ(M)
      COMMON/OTHER/INDEX(N)
	  COMMON/SM/smwt,nstr,ndip
      DIMENSION SYN(5000)
      OPEN(UNIT=7,FILE='juliea.dat',STATUS='OLD',ACCESS='SEQUENTIAL',
     +FORM='UNFORMATTED')
      OPEN(UNIT=8,FILE='julieb.dat',STATUS='OLD',ACCESS='SEQUENTIAL',
     +FORM='UNFORMATTED')
c      WRITE(6,35)
c  35  FORMAT(1X,'HOW MANY OBSERVATION RECORDS ARE YOU USING IN',/,
c     +1X,'THE INVERSION ')
c      READ(5,*) NREC
      WRITE(6,38)
  38  FORMAT(1X,'HOW MANY TIME WINDOWS ARE THERE')
      READ(5,*) JW
      OPEN(UNIT=1,FILE='PARAM.DAT',STATUS='OLD',ACCESS='SEQUENTIAL',
     +FORM='FORMATTED')
	read(1,*)xmag,xmo
	read(1,*)flen,fwid,sdim
	read(1,*)nstr,ndip
	read(1,*)tdp,bdp
	read(1,*)nrec
	close(1)	
	NMECH=1
	NSUBF=nstr*ndip 
        NN=NSUBF*NMECH*JW
	suma=0.
	write(6,*)' LISA: ',nrec,'RECORDS USED IN THE INVERSION'
      DO 10 J=1,NREC
      READ(7) NT
      READ(8) NT2
      IF(NT .NE. NT2) GO TO 100
      WRITE(6,999) NT
 999  FORMAT(1X,'LENGTH OF THIS RECORD IS = ',I5)
      IF(J .EQ. 1) L2=NT
      IF(J .GT. 1) L2=L2+NT
      IF(J .EQ. 1) L1=1
      IF(J .GT. 1) L1=L2-NT+1
      DO 11 K=1,NN
      READ(7) (SYN(I),I=1,NT)
      DO 444 I=1,NT
	  asyn=abs(syn(i))
	  suma=suma+asyn
 444  A(L1+I-1,K)=SYN(I)
  11  CONTINUE
      MUP=L1+NT-1
      READ(8) (B(IP),IP=L1,MUP)
  10  CONTINUE
	  nlm=mup*nn
	  avga=suma/nlm
	  smwt=90.*avga
	  write(6,*)' Sum of abs(Aij):',suma
	  write(6,*)' Num of elements:',nlm
	  write(6,*)' Avg abs(Aij) value:',avga
	  write(6,*)' Spatial-smoothing & Mo-min weight:',smwt 
C
C     APPLY LINEAR CONSTRAINTS.
C
      CALL CONSTRP(MUP,B,NSUBF,JW,NREC,NMECH,SYN)
  21  CLOSE(7)
      CLOSE(8)
      OPEN(UNIT=9,FILE='LISAOUT.DAT',STATUS='NEW')
      CALL NNLS(RNORM,MODE)
  16  WRITE(9,2) RNORM
      WRITE(9,3) MODE
      WRITE(9,4)
      WRITE(9,5) (X(I), I=1,N)
      WRITE(9,6)
      WRITE(9,5) (W(I), I=1,N)
   2  FORMAT(' EUCLIDEAN NORM OF THE FINAL RESIDUAL VECTOR,
     +((B-AX))= ',E14.5)
   3  FORMAT(' MODE= ',I5)
   4  FORMAT(//,' SOLUTION VECTOR')
   5  FORMAT(1X,6E13.5)
   6  FORMAT(//,' DUAL VECTOR')
  17  CLOSE(9)
      GO TO 50
  100 WRITE(6,14) NT,NT2
  14  FORMAT(1X,'NT= ',I5,' IS NOT EQUAL TO NT2= ',I5)
  15  FORMAT(4A4)
  50  STOP
      END
c
C     SUBROUTINE NNLS  (A,MDA,M,N,B,X,RNORM,W,ZZ,INDEX,MODE)
C     C.L.LAWSON AND R.J.HANSON 'SOLVING LEAST SQUARES PROBLEMS', PRENTICE-
C     HALL.
C     1974.
C
C        ......  NONNEGATIVE LEAST SQUARES  ......
C
C     GIVEN AN M BY N MATRIX, A, AND AN M-VECTOR, B, COMPUTE AN
C     N-VECTOR, X, WHICH SOLVES THE LEAST SQUARES PROBLEM
C
C                A * X = B  SUBJECT TO X .GE. 0
C
C     A(),MDA,M,N  MDA IS THE FIRST DIMENSIONING PARAMETER FOR
C     THE ARRAY, A().  ON ENTRY A() CONTAINS THE M BY N MATRIX A.  ON
C     EXIT A() CONTAINS THE PRODUCT MATRIX, Q*A, WHERE Q IS AN M BY M
C     ORTHOGONAL MATRIX GENERATED IMPLICITLY BY THIS SUBROUTINE.
C     B()     ON ENTRY B() CONTAINS THE M-VECTOR, B.  ON EXIT B()
C             CONTAINS Q*B.
C     X()     ON ENTRY X() NEED NOT BE INITIALIZED.  ON EXIT X() WILL
C             CONTAIN THE SOLUTION VECTOR.
C     RNORM   ON EXIT RNORM CONTAINS THE EUCLIDEAN NORM OF THE RESIDUAL
C             VECTOR.
C     W()     AN N-ARRAY OF WORKING SPACE.  ON EXIT W() WILL CONTAIN
C             THE DUAL SOLUTION VECTOR.  W WILL SATISFY W(I) = 0.
C             FOR ALL I IN SET P AND W(I) .LE. 0. FOR ALL I IN SET Z.
C     ZZ()    AN M-ARRAY OF WORKING SPACE.
C     INDEX() AN INTEGER WORKING ARRAY OF LENGTH AT LEAST N.
C             ON EXIT THE CONTENTS OF THIS ARRAY DEFINE THE SETS P
C             AND Z AS FOLLOWS..
C
C             INDEX(1)  THRU  INDEX(NSETP) = SET P.
C             INDEX(IZ1)  THUR  INDEX(IZ2) = SET Z.
C             IZ1 = NSETP + 1 = NPP1
C             IZ2 = N
C     MODE    THIS IS A SUCCESS-FAILURE FLAG WITH THE FOLLOWING
C             MEANINGS..
C
C             1    THE SOLUTION HAS BEEN COMPUTED SUCCESSFULLY.
C             2    THE DIMENSIONS OF THE PROBLEM ARE BAD.
C                  EITHER M .LE. 0 OR N .LE. 0.
C             3    ITERATION COUNT EXCEEDED.  MORE THAN 3*N ITERATIONS.
C
C
C
      SUBROUTINE NNLS(RNORM,MODE)
      INCLUDE 'ARSZLISA.DAT'
      COMMON/ALL/A(MDA,N)
      COMMON/REST/B(M),X(N),W(N),ZZ(M)
      COMMON/OTHER/INDEX(N)
      ZERO=0.
      ONE=1.
      TWO=2.
      FACTOR=0.01
C
      MODE=1
      IF(M .GT. 0 .AND. N .GT. 0) GO TO 10
      MODE=2
      RETURN
  10  ITER=0
      ITMAX=3*N
C
C                   INITIALIZE THE ARRAYS INDEX() AND X().
C
      DO 20 I=1,N
      X(I)=ZERO
  20  INDEX(I)=I
C
      IZ2=N
      IZ1=1
      NSETP=0
      NPP1=1
C
C                  .....  MAIN LOOP BEGINS HERE  .....
C
  30  CONTINUE
C
C                  QUIT IF ALL COEFFICIENTS ARE ALREADY IN THE
C                  SOLUTION OR IF M COLS OF A HAVE BEEN TRIANGULARIZED.
C
      IF(IZ1 .GT. IZ2 .OR. NSETP .GE. M) GO TO 350
C
C            COMPUTE COMPONENTS OF THE DUAL (NEGATIVE GRADIENT) VECTOR W().
C
      DO 50 IZ=IZ1,IZ2
      J=INDEX(IZ)
      SM=ZERO
      DO 40 L=NPP1,M
  40  SM=SM+A(L,J)*B(L)
  50  W(J)=SM
C
C                  FIND LARGEST POSITIVE W(J).
C
  60  WMAX=ZERO
      DO 70 IZ=IZ1,IZ2
      J=INDEX(IZ)
      IF(W(J) .LE. WMAX) GO TO 70
      WMAX=W(J)
      IZMAX=IZ
  70  CONTINUE
C
C                  IF WMAX .LE. 0. GO TO TERMINATION.
C                  THIS INDICATES SATISFACTION OF THE KUHN-TUCKER CONDITIONS.
C
      IF(WMAX) 350,350,80
  80  IZ=IZMAX
      J=INDEX(IZ)
C
C          THE SIGN OF W(J) IS OK FOR J TO BE MOVED TO SET P.  BEGIN THE
C          TRANSFORMATION AND CHECK NEW DIAGONAL ELEMENT TO AVOID NEAR
C          LINEAR DEPENDENCE.
C
      ASAVE=A(NPP1,J)
      CALL H12(1,NPP1,NPP1+1,M,A(1,J),1,UP,DUMMY,1,1,0)
      UNORM=ZERO
      IF(NSETP .EQ. 0) GO TO 100
      DO 90 L=1,NSETP
  90  UNORM=UNORM+A(L,J)**2
 100  UNORM=SQRT(UNORM)
      IF(DIFF(UNORM+ABS(A(NPP1,J))*FACTOR,UNORM)) 130,130,110
C
C          COL J IS SUFFICIENTLY INDEPENDENT.  COPY B INTO ZZ, UPDATE
C          ZZ AND SOLVE FOR ZTEST ( = PROPOSED NEW VALUE FOR X(J) ).
C
 110  DO 120 L=1,M
 120  ZZ(L)=B(L)
      CALL H12(2,NPP1,NPP1+1,M,A(1,J),1,UP,ZZ,1,1,1)
      ZTEST=ZZ(NPP1)/A(NPP1,J)
C
C                    SEE IF ZTEST IS POSITIVE.
C
      IF(ZTEST) 130,130,140
C
C          REJECT J AS A CANDIDATE TO BE MOVED FROM SET Z TO SET P.
C          RESTORE A(NPP1,J), SET W(J)=0., AND LOOP BACK TO TEST DUAL
C          COEFFS AGAIN.
C
 130  A(NPP1,J)=ASAVE
      W(J)=ZERO
      GO TO 60
C
C     THE INDEX J=INDEX(IZ) HAS BEEN SELECTED TO BE MOVED FROM SET
C     Z TO SET P.  UPDATE B, UPDATE INDICES, APPLY HOUSEHOLDER
C     TRANSFORMATIONS TO COLS IN NEW SET Z, ZERO SUBDIAGONAL ELTS IN
C     COL J, SET W(J)=0.
C
 140  DO 150 L=1,M
 150  B(L)=ZZ(L)
C
      INDEX(IZ)=INDEX(IZ1)
      INDEX(IZ1)=J
      IZ1=IZ1+1
      NSETP=NPP1
      NPP1=NPP1+1
C
      IF(IZ1 .GT. IZ2) GO TO 170
      DO 160 JZ=IZ1,IZ2
      JJ=INDEX(JZ)
 160  CALL H12(2,NSETP,NPP1,M,A(1,J),1,UP,A(1,JJ),1,MDA,1)
 170  CONTINUE
C
      IF(NSETP .EQ. M) GO TO 190
      DO 180 L=NPP1,M
 180  A(L,J)=ZERO
 190  CONTINUE
C
      W(J)=ZERO
C
C                  SOLVE THE TRIANGULAR SYSTEM. STORE THE SOLUTION
C                  TEMPORARILY IN ZZ().
C
      ASSIGN 200 TO NEXT
      GO TO 400
 200  CONTINUE
C
C                  .....  SECONDARY LOOP BEGINS HERE  .....
C                             ITERATION COUNTER
C
 210  ITER=ITER+1
      IF(ITER .LE. ITMAX) GO TO 220
      MODE=3
      WRITE(6,440)
      GO TO 350
 220  CONTINUE
C
C                  SEE IF ALL NEW CONSTRAINED COEFFS ARE FEASIBLE.
C                  IF NOT COMPUTE ALPHA.
C
      ALPHA=TWO
      DO 240 IP=1,NSETP
      L=INDEX(IP)
      IF(ZZ(IP)) 230,230,240
C
 230  T=-X(L)/(ZZ(IP)-X(L))
      IF(ALPHA .LE. T) GO TO 240
      ALPHA=T
      JJ=IP
 240  CONTINUE
C
C          IF ALL NEW CONSTRAINED COEFFS ARE FEASIBLE THEN ALPHA WILL
C          STILL = 2.  IF SO EXIT FROM SECONDARY LOOP TO MAIN LOOP.
C
      IF(ALPHA .EQ. TWO) GO TO 330
C
C          OTHERWISE USE ALPHA WHICH WILL BE BETWEEN 0. AND 1. TO
C          INTERPOLATE BETWEEN THE OLD X AND THE NEW ZZ.
C
      DO 250 IP=1,NSETP
      L=INDEX(IP)
 250  X(L)=X(L)+ALPHA*(ZZ(IP)-X(L))
C
C             MODIFY A AND B AND THE INDEX ARRAYS TO MOVE COEFFICIENT
C             I FROM SET P TO SET Z.
C
      I=INDEX(JJ)
 260  X(I)=ZERO
C
      IF(JJ .EQ. NSETP) GO TO 290
      JJ=JJ+1
      DO 280 J=JJ,NSETP
      II=INDEX(J)
      INDEX(J-1)=II
      CALL G1(A(J-1,II),A(J,II),CC,SS,A(J-1,II))
      A(J,II)=ZERO
      DO 270 L=1,N
      IF(L .NE. II) CALL G2(CC,SS,A(J-1,L),A(J,L))
 270  CONTINUE
 280  CALL G2(CC,SS,B(J-1),B(J))
 290  NPP1=NSETP
      NSETP=NSETP-1
      IZ1=IZ1-1
      INDEX(IZ1)=I
C
C             SEE IF THE REMAINING COEFFS IN SET P ARE FEASIBLE.  THEY
C             SHOULD BE BECAUSE OF THE WAY ALPHA WAS DETERMINED.  IF
C             ANY ARE INFEASIBLE IT IS DUE TO ROUND-OFF ERROR.  ANY
C             THAT ARE NONPOSITIVE WILL BE SET TO ZERO AND MOVED FROM
C             SET P TO SET Z.
C
      DO 300 JJ=1,NSETP
      I=INDEX(JJ)
      IF(X(I)) 260,260,300
 300  CONTINUE
C
C             COPY B() INTO ZZ().  THEN SOLVE AGAIN AND LOOP BACK.
C
      DO 310 I=1,M
 310  ZZ(I)=B(I)
      ASSIGN 320 TO NEXT
      GO TO 400
 320  CONTINUE
      GO TO 210
C
C             .....  END OF SECONDARY LOOP  .....
C
 330  DO 340 IP=1,NSETP
      I=INDEX(IP)
 340  X(I)=ZZ(IP)
C
C             ALL NEW COEFFS ARE POSITIVE.  LOOP BACK TO BEGINNING.
C
      GO TO 30
C
C             .....  END OF MAIN LOOP  .....
C             COME TO HERE FOR TERMINATION.  COMPUTE THE NORM
C             OF THE FINAL RESIDUAL VECTOR.
C
 350  SM=ZERO
      IF(NPP1 .GT. M) GO TO 370
      DO 360 I=NPP1,M
 360  SM=SM+B(I)**2
      GO TO 390
 370  DO 380 J=1,N
 380  W(J)=ZERO
 390  RNORM=SQRT(SM)
      RETURN
C
C             THE FOLLOWING BLOCK OF CODE IS USED AS AN INTERNAL
C             SUBROUTINE TO SOLVE THE TRIANGULAR SYSTEM, PUTTING
C             THE SOLUTION IN ZZ().
C
 400  DO 430 L=1,NSETP
      IP=NSETP+1-L
      IF(L .EQ. 1) GO TO 420
      DO 410 II=1,IP
 410  ZZ(II)=ZZ(II)-A(II,JJ)*ZZ(IP+1)
 420  JJ=INDEX(IP)
 430  ZZ(IP)=ZZ(IP)/A(IP,JJ)
      GO TO NEXT, (200,320)
 440  FORMAT(1X,' NNLS QUITTING ON ITERATION COUNT.')
      END
C
C     SUBROUTINE H12(MODE,LPIVOT,L1,M,U,IUE,UP,C,ICE,ICV,NCV)
C     C.L.LAWSON AND R.J.HANSON, 'SOLVING LEAST SQUARES PROBLEMS',
C     PRENTICE-HALL, 1974.
C
C     CONSTRUCTION AND/OR APPLICATION OF A SINGLE HOUSEHOLDER
C     TRANSFORMATION..    Q = I + U*(U**T)/B
C
C     MODE    = 1 OR 2 TO SELECT ALGORITHM H1 OR H2.
C     LPIVOT  IS THE INDEX OF THE PIVOT ELEMENT.
C     L1,M    IF L1 .LE. M THE TRANSFORMATION WILL BE CONSTRUCTED
C             TO ZERO ELEMENTS INDEXED FROM L1 THROUGH M.  IF L1
C             .GT. M THE SUBROUTINE DOES AN IDENTITY TRANSFORMATION.
C     U(),IUE,UP
C             ON ENTRY TO H1 U() CONTAINS THE PIVOT VECTOR. IUE IS
C             THE STORAGE INCREMENT BETWEEN ELEMENTS.  ON EXIT FROM
C             H1 U() AND UP CONTAIN QUANTITES DEFINING THE VECTOR U
C             OF THE HOUSEHOLDER TRANSFORMATION.  ON ENTRY TO H2 U()
C             AND UP SHOULD CONTAIN QUANTITIES PREVIOUSLY COMPUTED
C             BY H1.  THESE WILL NOT BE MODIFIED BY H2.
C     C()     ON ENTRY TO H1 OR H2 C() CONTAINS A MATRIX WHICH WILL
C             BE REGARDED AS A SET OF VECTORS TO WHICH THE HOUSEHOLDER
C             TRANSFORMATION IS TO BE APPLIED.  ON EXIT C() CONTAINS
C             THE SET OF TRANSFORMED VECTORS.
C     ICE     STORAGE INCREMENT BETWEEN ELEMENTS OF VECTORS IN C().
C     ICV     STORAGE INCREMENT BETWEEN VECTORS IN C().
C     NCV     NUMBER OF VECTORS IN C() TO BE TRANSFORMED.  IF NCV
C             .LE. 0 NO OPERATIONS WILL BE DONE ON C().
C
      SUBROUTINE H12(MODE,LPIVOT,L1,M,U,IUE,UP,C,ICE,ICV,NCV)
      DIMENSION U(IUE,M),C(1)
      DOUBLE PRECISION SM,B
      ONE=1.
C
      IF(0 .GE. LPIVOT .OR. LPIVOT .GE. L1 .OR. L1 .GT. M) RETURN
      CL=ABS(U(1,LPIVOT))
      IF(MODE .EQ. 2) GO TO 60
C
C               .....  CONSTRUCT THE TRANSFORMATION  .....
C
      DO 10 J=L1,M
  10  CL=AMAX1(ABS(U(1,J)),CL)
      IF(CL) 130,130,20
  20  CLINV=ONE/CL
      SM=(DBLE(U(1,LPIVOT))*CLINV)**2
      DO 30 J=L1,M
  30  SM=SM+(DBLE(U(1,J))*CLINV)**2
C
C               CONVERT DBLE PREC SM TO SNGL PREC SM1.
C
      SM1=SM
      CL=CL*SQRT(SM1)
      IF(U(1,LPIVOT)) 50,50,40
  40  CL=-CL
  50  UP=U(1,LPIVOT)-CL
      U(1,LPIVOT)=CL
      GO TO 70
C
C               .....  APPLY THE TRANSFORMATION I+U*(U**T)/B  TO C  .....
C
  60  IF(CL) 130,130,70
  70  IF(NCV .LE. 0) RETURN
      B=DBLE(UP)*U(1,LPIVOT)
C
C               B MUST BE NONPOSITIVE HERE.  IF B = 0., RETURN
C
      IF(B) 80,130,130
  80  B=ONE/B
      I2=1-ICV+ICE*(LPIVOT-1)
      INCR=ICE*(L1-LPIVOT)
      DO 120 J=1,NCV
      I2=I2+ICV
      I3=I2+INCR
      I4=I3
      SM=C(I2)*DBLE(UP)
      DO 90 I=L1,M
      SM=SM+C(I3)*DBLE(U(1,I))
  90  I3=I3+ICE
      IF(SM) 100,120,100
 100  SM=SM*B
      C(I2)=C(I2)+SM*DBLE(UP)
      DO 110 I=L1,M
      C(I4)=C(I4)+SM*DBLE(U(1,I))
 110  I4=I4+ICE
 120  CONTINUE
 130  RETURN
      END
C
      SUBROUTINE G1(A,B,COS,SIN,SIG)
C
C     C.L.LAWSON AND R.J.HANSON, 'SOLVING LEAST SQUARES PROBLEMS',
C     PRENTICE-HALL, 1974.
C
C     COMPUTE ORTHOGONAL ROTATION MATRIX.
C     COMPUTE..  MATRIX  (C, S) SO THAT (C, S)(A) = (SQRT(A**2+B**2))
C                        (-S,C)         (-S,C)(B)   (   0          )
C     COMPUTE SIG = SQRT(A**2+B**2)
C     SIG IS COMPUTED LAST TO ALLOW FOR THE POSSIBILITY THAT SIG
C     MAY BE IN THE SAME LOCATION AS A OR B.
C
      ZERO=0.
      ONE=1.
      IF(ABS(A) .LE. ABS(B)) GO TO 10
      XR=B/A
      YR=SQRT(ONE+XR**2)
      COS=SIGN(ONE/YR,A)
      SIN=COS*XR
      SIG=ABS(A)*YR
      RETURN
  10  IF(B) 20,30,20
  20  XR=A/B
      YR=SQRT(ONE+XR**2)
      SIN=SIGN(ONE/YR,B)
      COS=SIN*XR
      SIG=ABS(B)*YR
      RETURN
  30  SIG=ZERO
      COS=ZERO
      SIN=ONE
      RETURN
      END
C
      SUBROUTINE G2(COS,SIN,X,Y)
C
C     C.L.LAWSON AND R.J.HANSON, 'SOLVING LEAST SQUARES PROBLEMS',
C     PRENTICE-HALL, 1974.
C     APPLY THE ROTATION COMPUTED BY G1 TO (X, Y).
C
      XR=COS*X+SIN*Y
      Y=-SIN*X+COS*Y
      X=XR
      RETURN
      END
C
      FUNCTION DIFF(X,Y)
C     C.L.LAWSON AND R.J.HANSON, 'SOLVING LEAST SQUARES PROBLEMS',
C     PRENTICE-HALL, 1974.
      DIFF=X-Y
      RETURN
      END
C
      SUBROUTINE CONSTRP(MSTART,B,NSUBF,JW,NREC,NMECH,SYN)
c
c	Modified from Hartzell CONSTR subroutine (CMENDOZA/Nov2011)
c	This version applies spatial-smoothing and monent-minimization constraints 
c	using a prescribed weighting factor.  
C
C     NMECH...NUMBER OF DIFFERENT MECHANISMS PER SUBFAULT (1 OR 2)
C     NREC....TOTAL NUMBER OF RECORDS IN INVERSION
C     NSUBF...TOTAL NUMBER OF SUBFAULTS
C     MSTART..NUMBER OF ROWS IN 'A' MATRIX UPON ENTERING SUBROUTINE
C     JW......NUMBER OF TIME WINDOWS
C     M.......NUMBER OF ROWS IN 'A' MATRIX UPON EXITING SUBROUTINE
C     N.......NUMBER OF COLUMNS IN 'A' MATRIX
C
      INCLUDE 'ARSZLISA.DAT'
      COMMON/ALL/A(M,N)
	  COMMON/SM/smwt,nstr,ndip
      DIMENSION B(M),SYN(5000),RIGID(50)
      IC=MSTART+1
	  NSUBH=nstr
	  NSUBV=ndip
	  WTSMH=smwt
	  WTMIN=smwt
      NN=NSUBF*NMECH*JW
      IDENT=1
      DO 73 K=1,NN
      DO 74 I=1,N
      SYN(I)=0.
  74  IF(I .EQ. IDENT) SYN(I)=WTMIN
      DO 84 I=1,N
  84  A(IC,I)=SYN(I)
      IC=IC+1
      IDENT=IDENT+1
  73  CONTINUE
      MM=(NSUBF-NSUBV)*NMECH*JW
      IF(MM .EQ. 0) GO TO 75
      NUMZER=NSUBV*NMECH*JW-1
      ILOC1=1
      ILOC2=ILOC1+NUMZER+1
      DO 76 K=1,MM
      DO 77 I=1,N
      SYN(I)=0.
      IF(I .EQ. ILOC1) SYN(I)=WTSMH
  77  IF(I .EQ. ILOC2) SYN(I)=-WTSMH
      DO 85 I=1,N
  85  A(IC,I)=SYN(I)
      IC=IC+1
      ILOC1=ILOC1+1
      ILOC2=ILOC2+1
  76  CONTINUE
  75  MM=(NSUBF-NSUBH)*NMECH*JW
      IF(MM .EQ. 0) GO TO 25
      NUMZER=NMECH*JW-1
      ILOC1=1
      ILOC2=ILOC1+NUMZER+1
      ICOUNT=0
      ISTEP=NMECH*JW*NSUBV-NMECH*JW
      DO 79 K=1,MM
      ICOUNT=ICOUNT+1
      DO 81 I=1,N
      SYN(I)=0.
      IF(I .EQ. ILOC1) SYN(I)=WTSMH
  81  IF(I .EQ. ILOC2) SYN(I)=-WTSMH
      DO 86 I=1,N
  86  A(IC,I)=SYN(I)
      IC=IC+1
      ILOC1=ILOC1+1
      ILOC2=ILOC2+1
      IF(ICOUNT .EQ. ISTEP) GO TO 82
      GO TO 83
  82  ILOC1=ILOC1+NMECH*JW
      ILOC2=ILOC2+NMECH*JW
      ICOUNT=0
  83  CONTINUE
  79  CONTINUE
 25   MEND=IC-1
      NROWAD=MEND-MSTART
      WRITE(6,40) NROWAD
 40   FORMAT(1X,'THE NUMBER OF ROWS ADDED TO THE A MATRIX IN',/,
     +1X,'SUBROUTINE CONSTR IS ',I6)
      WRITE(6,37) MEND
 37   FORMAT(1X,'THE TOTAL NUMBER OF ROWS IN THE A MATRIX IS ',I6)
      IF(MEND .NE. M) THEN
      WRITE(6,38) M
 38   FORMAT(1X,'THE DIMENSION OF THE A MATRIX, ',I6,' ,IS NOT',/,
     +1X,'EQUAL TO THE TOTAL NUMBER OF ROWS....STOP')
      STOP
      ENDIF
      IC=MSTART+1
      DO 39 I=IC,MEND
 39   B(I)=0.
      RETURN
      END
